# wenbpack

## entry
```js
// entry 如果是一个文件的话那就是单入口 chunk名字就是main,每个chunk一般都会生成一个文件
// 指定多个文件 可以用正则 或者 glob库
  entry: {
    index: './src/index.js',
    login: './src/login.js',
    common: './src/common.js'
  },
```
## output
```js
  output: {
    path: path.join(__dirname, 'dist'), // 必须是绝对路径
    filename: '[name].[hash:8].js',
    //这个name 对于entry里面的key值
    // hash有3种  hash chunkHash contentHash 当原文件变化hash就变化 用来做缓存的 
  },
```
## 开启服务 webpack-dev-server
-  contentBase 指定开启那个目录
- 热更新
  -  内容修改 页面局部刷新
```js
  // 如果你使用了devServer那么所有产出的文件都会写到内存里,而不是写入到硬盘上,主要是为了速度
  devServer: {
    contentBase: path.join(__dirname, 'dist')
  },
```

## css
- css 处理都是单一原则,转换css需要2步
- css-loader style-loader
```js
  test：匹配处理文件的扩展名的正则表达式
  use：loader名称，就是你要使用模块的名称
  include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹
  query：为loaders提供额外的设置选项
```
- mini-css-extract-plugin 处理css 插件 将css单独提取出来 link到html中,取代style-loader
## html
- html-webpack-plugin
```js
  new HtmlWebpackPlugin({
    template: './src/index.html', // 指定的模板名字
    filename: 'index.html', // 产出的文件名
    hash: true, // 为了避免缓存,可以在产出的资源后面添加hash值
    chunks: ['common', 'index', 'login', ], //引入多个js文件 默认是乱序, 要加入的配置(manual 手动) 才安排数组顺序加入
    chunksSortMode: 'manual', // 对引入代码块进行排序 
  })
```
- 在css中处理less ,不需要单独处理less文件
- css引入less文件 `@import url('./less/index.less');` 注意要加';'
```js
{
  test: /\.css$/,
  use: [MiniCssExtractPlugin.loader, {
    loader:'css-loader',
    options:{
      importLoaders:2//这个配置是 后面引入的loader 暂时没有测出结果
    }
  }, 'postcss-loader','less-loader']
}
```

## 图片 文件
- file-loader   url-loader html-withimg-loader
- 加入图片方法 用js引入图片/css引入/html 引入
- file-loader 将图片复制到打包文件内 生成一个新的图片名字
- url-loader 内置了file-loader 添加配置 如果图片小于limit 他会变成base64字符串
- html-withimg-loader 他是在html中使用图片


## mode
- production 默认会压缩js css不会压缩 要开启 optimization选项优化
- development 不会压缩
## 压缩js css
- 用terser-webpack-plugin替换掉uglifyjs-webpack-plugin解决uglifyjs不支持es6语法问题
- `npm i uglifyjs-webpack-plugin terser-webpack-plugin optimize-css-assets-webpack-plugin -D`
- 注意项 mode必须设置production,此外配置了optimization选项原有的js 在production 打包压缩会失效,要手动引起插件开启
```js
const TerserPlugin = require('terser-webpack-plugin'); // 压缩js
const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");// 压缩css
  
  optimization: { // 这里放优化的内容
    minimizer: [ //表示放优化的插件
      // new TerserPlugin({
      //   parallel: true, //开启多进程并进行压缩
      //   cache: true, //开启缓存
      // }),
      new OptimizeCSSAssetsPlugin({

      })
    ]
  },
```
## hash
- hash 代表本次编译,每次编译一次,hash会变,所有的产出的hash都一样 默认是32位
- chunkHash 指文件内部引用变化 他就变化(一个chunk代表一组模块)
- contentHash 指单个文件内容变化 他才变化 
- 此外output filename只能用单独使用3个hash中的一种  因为contenthash指的是单个文件,contenthash会有很多，而filename指的是产出的是一个大文件,同样chunkhash也是css和js几类

## @意思
- 代表一类库

## glob 查找目录的所有文件
- cnpm i -S glob
```js
let glob = require('glob')

let rs = glob.sync('./src/**/*.{js,gif}')

console.log(rs) //返回src目录下所有的js和gif文件 不管多少层目录
```

## 预处理器
- cnpm i less less-loader node-sass sass-loader -D
```js
  {
    test: /\.less$/,
    use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader']
  },
  {
    test: /\.scss$/,
    use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader']
  }
```

## postcss
- cnpm i postcss-loader autoprefixer -D
- 增加前缀
- 用法 
  - 在处理css 里面增加一个`postcss-loader`处理器
  - 第二个增加一个配置文件 postcss.config.js 或者用 options添加配置
```js
{
  test: /\.css$/, // 如果用到import 或者 require 文件 是css
  use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader']
},
module.exports = {
  plugins: [require('autoprefixer')]
}
```
## babel 处理js
- cnpm i -D babel-loader @babel/core @babel/preset-react @babel/preset-env
- cnpm i -D @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties
- 配置有两种写法 下面是options配置 还可以创建一个.babelrc文件 将options里的对象 复制过去
```js
{
  test: /\.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      "presets": [ // 插件的集合
        "@babel/preset-env", //转义ES6 ES7
        "@babel/preset-react", //转义 jsx语法
      ],
      "plugins": [ // 每个插件代表一个规则 需要传递参数 就写成数组
        ["@babel/plugin-proposal-decorators", { legacy: true }],// 处理装饰器语法
        ["@babel/plugin-proposal-class-properties", { loose: true }],//处理类的属性 
        // loose松散模式 
      ]
    }
  }
}
```
- babel runtime
- babel 在每個文件都插入了辅助代码,使体积过大
- babel 对一些公共方法使用了非常小的辅助代码 比如 _extend
- 默认情况下会被添加到每一个需要它的文件中,可以引入 `@babel/runtime`作为一个独立的模块,来避免重复引入
- `cnpm i -S @babel/plugin-transform-runtime @babel/runtime`  @babel/plugin-transform-runtime 是插件 他会依赖@babel/runtime
```js
"plugins":[
  ['@babel/plugin-transform-runtime',{
    corejs:false,
    helpers:true,
    regenerator:true,
    useESModules:true
  }]
]

```
## eslint
- `cnpm i eslint eslint-loader babel-eslint -D`
- eslint 是核心库 eslint-loader loader作用 babel-eslint 转义高级语法
- 创建配置文件 .eslintrc.js
- [eslint-config-airbnb](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb)
- `cnpm i eslint-config-airbnb eslint-loader eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks and eslint-plugin-jsx-a11y -D`
```js
module.exports = {
  "parser":"babel-eslint",// 把源码转成语法树的工具
  "extends":"airbnb",// 继承airbnb规则
  env:{ //指定运行环境
    browser:true,
    node:true
  },
  rules:{
    "linebreak-style":"off"
    }
};
```
## 引入字体
- 配置loader
```js
{
 test:/\.(woff|ttf|eot|svg|otf)$/,
     use:{
                    //url内部内置了file-loader
        loader:'url-loader',
        options:{//如果要加载的图片大小小于10K的话，就把这张图片转成base64编码内嵌到html网页中去
       limit:10*1024
       }
   }
 },
```
- 使用字体文件
```js
@font-face {
    src: url('./fonts/HabanoST.otf') format('truetype');
    font-family: 'HabanoST';
}

.welcome {
    font-size:100px;
    font-family: 'HabanoST';
}
```

## 打包调试
- sourcemap是为了解决开发代码与实际运行代码不一致时帮助我们debug到原始开发代码的技术
  - 不能缓存source-map文件,每次编译都会生成新的代码块文件,在生成环境下会影响性能
  - 性能最差,效果最好,会生成一个source-map文件 能定位到行和列 
- eval 
  - 生成代码 每个模块都被eval执行，并且存在@sourceURL,带eval的构建模式能cache SourceMap
  - 用最好的性能,但是只能映射到编译后的代码 主要是把编译前和后的代码关联起来
  - 1、不需要生成单独的source-map文件
  - 2、eval代码包裹起来代码可以缓存
- cheap 
  - 不包含列表信息
  - cheap-source-map 定位到行 但是是编译后的文件(不包含loader等)
- module
  - 包含loader的source-map(比如jsx to js,babel的source-map,源文件显示需要babel等loader处理,打包后的都是不需要loader处理的),否则无法定义源文件
  - cheap-module-source-map 定位到行 显示的源文件的代码
- inline 
  - 不会生成单独的source-map文件 将.map作为DataURL(base64)嵌入 到打包文件内

## 打包第三方库
- 1、直接引用
```js
import _ from 'lodash';
alert(_.join(['a','b','c'],'@'));
```
- 2、插件引用
webpack配置ProvidePlugin后，在使用时将不再需要import和require进行引入，直接使用即可
- 函数会自动添加到当前模块的上下文，无需显示声明
- 这种注入模块相当于向模块内部注入了一个局部变量
```js
 new webpack.ProvidePlugin({
     _:'lodash'
 })
```
- 3、expose-loader
- 不需要任何其他的插件配合，只要将下面的代码添加到所有的loader之前
- loader传参数 有2种方式 ?和options
```js
// ?是传参  !是分隔loader 和 原模块
require("expose-loader?$!jquery");
// 或者
{ 
  test: require.resolve("jquery"), 
  loader: "expose-loader?jQuery"
}
```
### externals 
- 如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals
- html-webpack-externals-plugin
```js
const jQuery = require("jquery");
 import jQuery from 'jquery';

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
 externals: {
  jquery: 'jQuery'
},
```

- 2、通过插件
```js
new htmlWebpackExternalsPlugin({
  externals:[
    {
      module:'$',//页面引入模块的名字
      entry:'https://cdn.bootcss.com/jquery/3.4.1/jquery.js',
      global:'jQuery',//从全局对象的那个属性上获取导出的值
    }
  ]
})
```

## watch
- 当代码发生修改后可以自动重新编译
```js
module.exports = {
    //默认false,也就是不开启
    watch:true,
    //只有开启监听模式时，watchOptions才有意义
    watchOptions:{
        //默认为空，不监听的文件或者文件夹，支持正则匹配
        ignored:/node_modules/,
        //监听到变化发生后会等300ms再去执行，默认300ms
        aggregateTimeout:300,
        //判断文件是否发生变化是通过不停的询问文件系统指定议是有变化实现的，默认每秒问1000次
        poll:1000
    }
}
```

## 添加商标
```js
 new webpack.BannerPlugin('珠峰培训'),
```

## 拷贝静态文件 
```js
npm i copy-webpack-plugin -D
new CopyWebpackPlugin([{
  from: path.resolve(__dirname,'src/assets'),//静态资源目录源地址
  to:path.resolve(__dirname,'dist/assets') //目标地址，相对于output的path目录
}])
```
## 清空目录
- clean-webpack-plugin
```js
npm i  clean-webpack-plugin -D
const {CleanWebpackPlugin} = require('clean-webpack-plugin');
plugins:[
new CleanWebpackPlugin({cleanOnceBeforeBuildPatterns: ['**/*', '!static-files*'],})
]
```

## 服务器代理 
```js
proxy:{
  // "/api":"http://localhost:3000",//这个情况是 访问 localhost:8080/api/users =>映射到 localhost:3000/api/users
  "/api":{
    target:"http://localhost:3000",
    pathRewrite:{
      "^/api":"",// api开头的 改为空
    },// 这种情况是  访问 localhost:8080/api/users =>映射到 localhost:3000/users
  }
}
```